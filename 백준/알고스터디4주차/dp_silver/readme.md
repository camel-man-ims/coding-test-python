# 알고리즘 4주차 dp silver

## 1. 쉬운 계단수

* [쉬운 계단수 풀이](./쉬운계단수/BJ10844.py)
  * date: 22.07.21

### 1-1) 문제 설명

`45656` 과 같은 숫자가 있을 때, 해당 숫자는 모든 숫자가 1씩 차이가 나고, 해당 수를 계단수라고 한다.
숫자 n이 주어질 때, 게단수의 개수를 구하라.

### 1-2) 문제 풀이: 아이디어

* 실패
  * 처음에는 규칙성을 찾았을 때 다음과 같이 생각했다.
    * 1 ~ 9 가 있을 때, 앞뒤로 숫자가 +1, -1 붙을 수 있다.
    * 그렇기 때문에 경우의 수는 전의 항 *4인데, 반마다 중복으로 집계가 되므로 /2를 해준다. 그리고 0, 9 예외값에 대해서 -1을 해준다.
    * 그래서 `dp[i] = dp[i-1]*2-1` 이런식으로 생각했는데 틀렸다. 
    
* 풀이 생각
  * 나는 23 이렇게 숫자가 있으면 2앞으로 +1,-1 // 3뒤로 +1, -1 이렇게 생각했는데, 앞의 +1 -1은 **이미 지난 경우의 수에서 센 것**으로 counting을 해줘야 한다.
  * 그렇기 때문에 23의 경우 22, 24 이렇게 뒤 경우의 수 +1, -1 만 따져주면 된다.

### 1-3) 문제 풀이: 코드

* dp 테이블의 의미
  * dp테이블은 항상 테이블이 무엇을 의미하는 지 아는 것이 중요하다.
  * `dp[i][j]` 가 의미하는 것은 i자리수 일 때, 마지막 수가 j일 때 구성될 수 있는 경우의 수다.
    * ex) `dp[3][3]`
      * 123, 323, 543 등 자리수가 3이고 끝나는 수가 3일 때 만들어질 수 있는 경우의 수

* `dp[i][0]`의 값은 `dp[i-1][1]` 와 같다.
  * 왜냐하면 예를들어 9자리 수에서 끝자리가 0을 만들려면 8자리 수에서 끝자리가 1인 수에서 0을 붙이는 방법밖에 없기 때문이다. 
  * 마찬가지로`dp[i][9]`의 값은 `dp[i-1][8]` 에서 1을 더해준다.

* `dp[i][j]`의 값은 `dp[i-1][j-1] + dp[i-1][j+1]` 을 해준다.
  * 이는 만약 세 자리 수에서 끝 자리가 3인 수를 만들려면 두 자리 수에서 -2, -4 의 경우의 수를 더해줘야 되기 때문이다.




